## 생명주기  
 김예나  

+ 생명주기 즉, 라이프사이클 -> 앱이 실행되는 순서

+ 플러터가 StatefulWidget을 만들 때, State객체도 만든다.  
->이 객체는 해당 위젯의 모든 변할수 있는 상태가  유지 되는 곳  
+ state의 개념  
1.위젯에 의해서 사용되어지는 데이터는 변할수 있다.  
2.위젯이 빌드 될때 데이터를 동시에 읽을 수 없다. ->모든 state는 build 메서드가 호출 될때 까지 설정 되어야 한다.  
+ StatefulWidget 와 State 는 클래스를 분리한다.   
 - State객체는 오래 유지됨  
    1.State는 재구축할때 마다 폐기되지 않음 -> 큰 비용 계산을 피할 수 있음/프레임별로(frame)로 프레임이 재구성 될때 마다 state속성, getter, setter등에서 가져옴  
->**State는 폐기되지 않으므로 언제든지 위젯을 재구성 가능**  
 2. StatefulWidgets(및 모든 Widget의 서브클래스)는 구성이 변경 될때마다 폐기하고 다시 작성됨 
 ->이것은 매우 저렴  

---  
StatelessWidget :상태를 연결할 필요가 없는 위젯으로 단순히 보여주기만 하는 역할  
StatefulWidget :상태가 연결된 동적인 위젯으로 여러가지 액션 즉, 상태를 변화시켜주는 역할  

- StatelessWidget의 생명주기 : 변경할 수 없는 상태를 갖기 때문에 build만 진행    

- StatefulWidget의 생명주기 : StatefulWidget에서 createState()를 통해 상태가 생성. State는 initState - build - setState, didUpdateWidget - dispose의 순서로 생명주기를 가짐     


---  
1. **createState()**
   * 위젯의 상태를 생성하는 함수
   * 플러터가 StatefulWidget을 빌드하도록 지시하면 호출되는 것 
   * 반드시 존재해야 함   

2. **mounted is true**  
   * createState가 state클래스를 생성하면 buildContext는 state에 할당  
   * 모든 위젯은 bool형식의 this.mounted 속성을 가짐  
   * buildContext가 할당되면 true를 리턴  
    * 위젯이 unmounted상태일때 setState를 호출하면 error가 발생  
 
3. **initState()**
	
	* 데이터 목록을 만들거나 처음 필요한 데이터를 주고받을 때 호출 
   * 위젯이 생성될때 처음으로 호출되는 메서드
   * initState는 위젯을 초기화할 때 오직 한번만 호출
   * 반드시 super.initState()를 호출해야함 
4. **didChangeDependencies()**  
    
	* 위젯이 최초 생성될때 initState 다음에 바로 호출됨
   * 위젯이 의존하는 데이터의 객체가 호출될때마다 호출   
   * ex)업데이트되는 위젯을 상속한 경우.
5. **build()**
	
	* 버튼을 누르거나 액션을 할 경우마다 호출
   * Widget을 반환하여 화면에 렌더링  
   * <u>반드시 Widget을 리턴해야 함</u> 
6. **didUpdateWidget(Widget oldWidget)**
   
   * 부모 위젯이나 데이터가 변경되어 위젯을 갱신해야 할 때 호출
   * initState()에서 처럼 일부 데이터를 다시 초기화 해야 함
   
7. **setState()**

   * 플러터 앱 개발에서 가장 많이 호출되는 함수
	* 위젯의 상태를 갱신
	* '데이터가 변경되었음’을 프레임워크에 알리는데 사용
   * 변경된 데이터를 이용해 화면의 UI를 변경할 수 있도록 함 

8. **deactivate()**
   
   * State 객체를 플러터의 구성 트리로부터 제거할 때 호출
   * 호출되더라도 dispose() 함수의 호출 전까지는 State 객체의 재사용이 가능     

9. **dispose()**

   *  State 객체를 완전히 제거할 때 호출 ->해당 위젯을 종료한다는 뜻

10. **mounted is false**
   *  이 상태에서 state 객체는 결코 다시 mount되지 않음
   *  setState()가 호출되면 에러가 발생 
