#Provider

+  Provider 패턴을 쓰는 이유
	1. 코드를 역할에 따라서 나누기 위해->즉, 한 클래스가 하나의 역할만 가지도록 하기 위해(한 클래스가 여러 역할을 하면 관리어려움)  
	2. 데이터 공유를 쉽게 하기 위하여(하나의 데이터를 여러 페이지에서 공유 등)  
	3. 좀 더 적은 코드로 클래스 구분해서 쓸 수 있음(Bloc패턴은 코드가 좀 복잡)  
	4. 단, 대규모 프로젝트보다는 소규모,중규모 프로젝트에 적합함    

  
+  Provider은 데이터 생산,소비 2개의 부분으로 되어있음  

+  Provider 데이터 생산->데이터 생산 시에는 무조건 데이터 타입을 적어야함  
      
+  Provider 데이터 소비  
-Provider에서 만든 데이터를 쓰려면 두 가지 방법이 있음  
 	1. Provider.of(context)위젯  
		var data = Provider.of<내가 만든 프로바이더 이름(데이터타입)>(context)// 가까운 Provider로부터 값을 가져옴  
 	2. Consumer위젯 (위젯이 자주 재빌드 되는 것이 맘에 안 들면 사용)    
            		->빌더를 필요로 함!  
		Consumer<내가만든 프로바이더 이름>(  
		builder:(context,provider,child){return Text  (''),} )      
	3. Selector위젯  
            return Selector<내가만든 프로바이더 이름, 데이터의 자료형>(   
            selector: (_, state) => state.input, //state.input,이 바뀐다면 Selector가 다시 작성됨  
            builder: (context,provider,child) {  
      return Text('');  
    },  
  );  

+ Provider를 쓰려면 부모 위젯을 Provider로 감싸줘야 함! 만약 전체 앱에서 사용하고 싶으면 MateriapApp을 감싸면 됨  

+ 변하는 값을 처리해 주는 방법  
	1. ChangeNotifierProvider로 부모 위젯을 감싸줘야 함(builder 속성 필요)  
	2. ChangeNotifier을 클래스에 사용해야함(with키워드나 extends키워드를 사용해 주면 됨)  
	3. notifyListeners을 사용해야함(setState()처럼 UI에 있는 값이 변했을 때, UI를 변경해 주기 위해서 사용)  

+ 여러 Provider를 사용해 주기 위해서는 MultiProvider를 사용해 주면 됨  
	return MultiProvider(  
      providers: [  
        (Provider.of(context)위젯)  
        (Provider.of(context)위젯)  
      ],  
    );    
->만약 같은 자료형이 여러개라면 가장 밑에 있는 값으로 처리함  